package javaLambda;

/*
 * 람다식을 작성하는 방법
 * ==> (타입 매개변수, ...) -> { 실행문; ... }
 * ==> (타입 매개변수, ...)는 오른쪽 중괄호 { } 블록을 실행하기 위해 필요한 값을 제공.
 * 
 * 매개 변수의 이름은 자유롭게 지정 가능.
 * 
 * -> 기호는 매개 변수를 이용해서 중괄호 { }를 실행한다는 의미.
 * ==> 예를 들어 int 매개 변수 a 의 값을 콘솔에 출력하기 위한 람다식은 다음과 같다.
 * ==> (int a) -> { System.out.println(a); }
 * 
 * 람다식의 매개 변수 타입은 런타임 시에 대입되는 값에 따라 컴파일러에 의한 타입 유추로 
 * 자동 인식되기 때문에 람다식에서는 매개 변수의 타입을 일반적으로 언급하지 않음.
 * ==> (a) -> { System.out.println(a); }
 * 
 * 하나의 매개 변수만 있다면 괄호 ()를 생략할 수 있고, 
 * 하나의 실행문만 있다면 중괄호 {}도 생략 가능.
 * ==> a ->  System.out.println(a)
 * 
 * 만약 매개 변수가 없다면 람다식에서 매개 변수 자리가 없어지므로 
 * 빈 괄호 () 를 반드시 사용해야 됨.
 * ==> () ->  System.out.println("Hello");
 * 
 * 중괄호 {}를 실행하고 결과값을 리턴해야 한다면 
 * return 문으로 결과값을 지정할 수 있음.
 * ==> (a,b) ->  { return a+b; }
 * 
 * 중괄호 {}에 return 문이 있을 경우, 
 * 람다식에서는 return 문을 사용하지 않고 다음과 같이 작성하는 것이 정석.
 * ==> (a,b) ->  a + b; 
 * 
 * 람다식의 형태는 매개 변수를 가진 코드 블록이기 때문에 마치 자바의 메소드를 선언하는 것처럼 보인다.
 * 자바는 메소드를 단독으로 선언할 수 없고 항상 클래스의 구성 멤버로 선언하기 때문에 
 * 람다식은 단순히 메소드를 선언하는 것이 아니라 이 메소드를 가지고 있는 익명 클래스의 객체를 생성하는 것을 의미.
 * 
 * 그럼 어떤 타입의 객체를 생성하는지 어떻게 알 수 있을까?
 * 인터페이스 변수 = 람다식;
 * 람다식은 인터페이스 변수에 대입됩니다. 이 말은 람다식은 인터페이스의 익명 구현 객체를 생성한다는 뜻이 됩니다.
 * 인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스가 필요한데, 람다식은 익명 구현 클래스를 생성하고 객체화합니다.
 * 람다식은 대입될 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에 람다식이 대입될 인터페이스를 
 * 람다식의 타겟 타입이라고 합니다.
 * 
 * 모든 인터페이스를 람다식의 타겟 타입으로 사용할 수 없습니다. 
 * 람다식이 하나의 메소드를 정의하기 때문에 두 개 이상의 추상 메소드가 선언된 인터페이스는 
 * 람다식을 이용해서 구현 객체를 생성할 수 없습니다.
 * 
 * 하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있는데, 
 * 이러한 인터페이스를 함수적 인터페이스(functional interface)라고 합니다.
 * 함수적 인터페이스를 작성할 때 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능이 있는데, 
 * 인터페이스 선언 시 @FunctionalInterface 어노테이션을 붙이면 됩니다.
 * 이 어노테이션은 두 개 이상의 추상 메소드가 선언되면 컴파일 오류를 발생시킵니다.
 * 
 * @FunctionalInterface 어노테이션은 선택사항입니다. 
 * 이 어노테이션이 없더라도 하나의 추상 메소드만 있다면 모두 함수적 인터페이스입니다.
 * 그러나 실수로 두 개 이상의 추상 메소드를 선언하는 것을 방지하고 싶다면 붙여주는 것이 좋습니다.
 * 
 * 
 * 매개 변수와 리턴값이 없는 람다식
 * 다음과 같이 매개 변수와 리턴값이 없는 추상 메소드를 가진 함수적 인터페이스가 있다고 가정해봅시다.
	@FunctionalInterface
	public interface MyFunctionalInterface {
	    public void method();
	}
 * 이 인터페이스를 타켓 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야 합니다.
 * 람다식에게 매개 변수가 없는 이유는 method() 가 매개 변수를 가지지 않기 때문입니다.
 * 
 * MyFunctionalInterface test = () -> { }
 * 
 * 람다식이 대입된 인터페이스의 참조 변수는 다음과 같이 method()를 호출할 수 있습니다.
 * method() 호출은 람다식의 중괄호 {}를 실행시킵니다.
 * 
 * test.method();
 * 
 * 	
 */
@FunctionalInterface
interface Exam02_MyFuncInterface1 {
	public int method(int k);
}

@FunctionalInterface
interface Exam02_MyFuncInterface2 {
	public void method(int k);
}

public class Exam02_LambdaExpression {

	public static void main(String[] args) {
		Exam02_MyFuncInterface1 test1 = a -> a+10;
		System.out.println(test1.method(10));
		
		Exam02_MyFuncInterface2 test2 = a -> { System.out.println(a); };
		test2.method(10);

	}
}